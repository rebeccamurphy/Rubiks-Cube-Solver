package rubik;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;

public class IDAStar {

	public static int nextBound;
	public static int nodesVisited;
	public static PriorityQueue<CubeNode> frontier = new PriorityQueue<CubeNode>();
	public static HashSet<CubeNode> explored = new HashSet<CubeNode>();
	
	public String doIDAStar(String state, boolean details){
		if (state.equals(Cube.GOAL_STRING)){
			return "The cube is already solved";
		}
		
		//CubeNode startState = new CubeNode(state);
		//make the first cube node	
		
		//set the nextbound to the orignal value
		//nextBound = startState.heuristic; 
		
		//set nodes visited
		nodesVisited =0;
		
		//init end
		
		CubeNode end = null;
		//Loop until the solution is found
		while (end == null) {
			if (details) {
				System.out.println("Current bound is: " + nextBound);
				System.out.println("# of Nodes visited: " + nodesVisited);
			}
			//frontier.add(start);
			end = search(nextBound);
			// The iterative-deepening portion of IDA*
			// Increment the bound if we haven't found a solution
			nextBound++;
			// Reset the frontier and exploredSet
			frontier.clear();
			explored.clear();
		}
		if (details) {
			System.out.println("Solved!");
			System.out.println("Total # of nodes visited: " + nodesVisited);
		}
		return formatOptimalSolution(end.path);
		
		return state;
		
	}
	/**
	 * The recursive expanding function that will expand nodes as per
	 * the rules of IDA*
	 * @param bound the current bound - used to determine if we should
	 *              expand nodes or not
	 * @return the node representation of the goal state
	 */
	private static CubeNode search(int bound) {
		nodesVisited++;

		while (!frontier.isEmpty()) {
			nodesVisited++;
			CubeNode current = frontier.poll();
			// If we have found the goal, return the goal node
			if (current.state.equals(Cube.GOAL_STRING)) {
				return current;
			}
			// Add this current node to our explored set
			explored.add(current);
			// Get all of the possible successors from the given node
			ArrayList<CubeNode> successors = CubeNode.getSuccessors(current);
			// Iterate over each of the successors
			for (CubeNode successor : successors) {
				int f = current.g + successor.heuristic;
				successor.g = current.g + 1;
				if (f <= bound && !explored.contains(successor)) {
					// Add it to our frontier
					frontier.add(successor);
				}
			}
		}
		// We did not find the solution at this bound
		return null;
	}
	
	/**
	 * Reads the CSV files for the heuristics and returns an int[]
	 * where the values are the heuristic values
	 * @param h the size of the array
	 * @param fileName the name of the CSV file to read from
	 * @return an int[]
	 */
	private static int[] readHeuristics(int h, String fileName) {
		// Our corners heuristics array will have 88179840
		// elements, but not all of them will have a value
		// as we only calculated heuristics for valid corner
		// positions starting at the goal state rather than
		// all possible permutations of corners.
		int[] heuristics = new int[h];
		FileReader file = null;
		String line;
		try {
			file = new FileReader(fileName);
			BufferedReader reader = new BufferedReader(file);
			while ((line = reader.readLine()) != null) {
				// For each line, split by the comma
				String[] lineData = line.split(",");
				// lineData[0] will be the encoded corner value
				// lineData[1] will be the calculated heuristic
				if (!(lineData[0].equals("") || lineData[1].equals(""))) {
					heuristics[Integer.parseInt(lineData[0])] = Integer.parseInt(lineData[1]);
				}
			}
		} catch (FileNotFoundException e) {
			throw new RuntimeException("File not found");
		} catch (IOException e) {
			throw new RuntimeException("IO error occurred");
		} finally {
			if (file != null) {
				try {
					file.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		return heuristics;
	}
	
}
