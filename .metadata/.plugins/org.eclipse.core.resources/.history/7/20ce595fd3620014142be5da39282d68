package rubik;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;

public class IDAStar {

	public static int nextBound;
	public static int nodesVisited;
	public static PriorityQueue<CubeNode> frontier = new PriorityQueue<CubeNode>();
	public static HashSet<CubeNode> explored = new HashSet<CubeNode>();
	
	public String doIDAStar(String state, boolean details){
		if (state.equals(Cube.GOAL_STRING)){
			return "The cube is already solved";
		}
		
		//CubeNode startState = new CubeNode(state);
		//make the first cube node	
		
		//set the nextbound to the orignal value
		//nextBound = startState.heuristic; 
		
		//set nodes visited
		nodesVisited =0;
		
		//init end
		
		CubeNode end = null;
		//Loop until the solution is found
		while (end == null) {
			if (details) {
				System.out.println("Current bound is: " + nextBound);
				System.out.println("# of Nodes visited: " + nodesVisited);
			}
			//frontier.add(start);
			end = search(nextBound);
			// The iterative-deepening portion of IDA*
			// Increment the bound if we haven't found a solution
			nextBound++;
			// Reset the frontier and exploredSet
			frontier.clear();
			explored.clear();
		}
		if (details) {
			System.out.println("Solved!");
			System.out.println("Total # of nodes visited: " + nodesVisited);
		}
		return formatOptimalSolution(end.path);
		
		return state;
		
	}
	/**
	 * The recursive expanding function that will expand nodes as per
	 * the rules of IDA*
	 * @param bound the current bound - used to determine if we should
	 *              expand nodes or not
	 * @return the node representation of the goal state
	 */
	private static CubeNode search(int bound) {
		nodesVisited++;

		while (!frontier.isEmpty()) {
			nodesVisited++;
			CubeNode current = frontier.poll();
			// If we have found the goal, return the goal node
			if (current.state.equals(Cube.GOAL_STRING)) {
				return current;
			}
			// Add this current node to our explored set
			explored.add(current);
			// Get all of the possible successors from the given node
			ArrayList<CubeNode> successors = CubeNode.getSuccessors(current);
			// Iterate over each of the successors
			for (CubeNode successor : successors) {
				int f = current.g + successor.heuristic;
				successor.g = current.g + 1;
				if (f <= bound && !explored.contains(successor)) {
					// Add it to our frontier
					frontier.add(successor);
				}
			}
		}
		// We did not find the solution at this bound
		return null;
	}
	
}
