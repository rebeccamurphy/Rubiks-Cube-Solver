package rubik;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;

public class IDAStar {

	public static int nextBound;
	public static int nodesVisited;
	public static boolean details;
	public static PriorityQueue<CubeNode> frontier = new PriorityQueue<CubeNode>();
	public static HashSet<CubeNode> explored = new HashSet<CubeNode>();
	public static int[] corners;
	public static int[] edgesSetOne;
	public static int[] edgesSetTwo;
	
	public static String doIDAStar(String state, boolean moreInfo){
		 /*Sudo code for IDA*
		 node              current node
		 g                 the cost to reach current node
		 f                 estimated cost of the cheapest path (root..node..goal)
		 h(node)           estimated cost of the cheapest path (node..goal)
		 cost(node, succ)  path cost function
		 is_goal(node)     goal test
		 successors(node)  node expanding function
		 */
		
		//extra variable for debuggine purposes
		details = moreInfo;
		if (state.equals(Cube.GOAL_STRING)){
			return "The cube is already solved";
		}
		try {
			corners = readHeuristicFile(88179840, "corners.csv");
			edgesSetOne = readHeuristicFile(42577920, "edgeSetOne.csv");
			edgesSetTwo = readHeuristicFile(42577920, "edgeSetTwo.csv");
		} catch (NumberFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Cube cubeStart = new Cube(state);
		int encodedCorner = cubeStart.encodeCorners();
		int startHeuristic = (encodedCorner > IDAStar.corners.length) ? 0: IDAStar.corners[encodedCorner];
		
		CubeNode startState = new CubeNode(state, startHeuristic);
		//make the first cube node	
		
		//set the nextbound to the original value
		nextBound = startState.hval; 
		
		//set nodes visited
		nodesVisited =0;
		
		//initilize end as null
		
		CubeNode end = null;
		
		//keep going until the solution is found
		while (end == null) {
			if (details) {
				System.out.println("Current bound is: " + nextBound);
				System.out.println("Number of Nodes visited: " + nodesVisited);
			}
			frontier.add(startState);
			end = search(nextBound);
			// The iterative-deepening portion of IDA*
			// Increment the bound if a solution isn't found
			nextBound++;
			// Clear the frontier and explored
			frontier.clear();
			explored.clear();
		}
		if (details) {
			System.out.println("Solved!");
			System.out.println("Total # of nodes visited: " + nodesVisited);
		}
		return end.path;
		
		
	}
	/**
	 * The recursive function for IDA*
	 * @param bound the current bound - used to tell if nodes need to be expanded
	 * @return the node version of the goal state (eventually) (hopefully)
	 */
	private static CubeNode search(int bound) {
		nodesVisited++;

		while (!frontier.isEmpty()) {
			nodesVisited++;
			CubeNode current = frontier.poll();
			//If the goal has been reached, return the goal node
			if (details){
				System.out.println("Current State: " + current.state);
			}
			if (current.state.equals(Cube.GOAL_STRING)) {
				return current;
			}
			
			// Add this current node to our explored set
			explored.add(current);
			
			// Get all of the possible successors from the current cube node
			ArrayList<CubeNode> successors = CubeNode.getSuccessors(current);
			
			// Go through each successor
			for (int i =0; i<successors.size(); i++) {
				int f = current.g + successors.get(i).hval;
				successors.get(i).g = current.g + 1;
				if (f <= bound && !explored.contains(successors.get(i))) {
					// Add it to our frontier
					frontier.add(successors.get(i));
				}
			}
		}
		//If the solution wasn't found at the current bound return null
		return null;
	}
	
	
	private static int[] readHeuristicFile (int fileLength, String fileName) throws NumberFormatException, IOException {
		int[] heuristics = new int[fileLength];
		FileReader file = null;
		String line; 
		try {
			file = new FileReader(fileName);
			BufferedReader reader = new BufferedReader(file);
			while ((line = reader.readLine()) != null) {
				// For each line, split by the comma
				String[] lineState = line.split(",");
				//As in the function to generate the heuristics, [0] is the encoded state,[1] is the hval
				if (!(lineState[0].equals("") || lineState[1].equals(""))) 
				{	if (Integer.parseInt(lineState[0]) <fileLength)
						heuristics[Integer.parseInt(lineState[0])] = Integer.parseInt(lineState[1]);
				}
			}
			reader.close();
		} catch (FileNotFoundException e) {
			throw new RuntimeException("File not found");
		}

		return heuristics;
	}
	
}
