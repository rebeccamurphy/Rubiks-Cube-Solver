package rubik;

import java.util.Arrays;
import java.util.HashMap;

public class Cube {
	public static String GOAL_STATE = "RRRRRRRRRGGGYYYBBBGGGYYYBBBGGGYYYBBBOOOOOOOOOWWWWWWWWW";
	static int[][] corners =new int[][]{
		//starting 0,0
		//X  Y  Z
		{12, 11, 6}, //0-00
		{30, 29, 36},//0-02
		
		{51, 9, 0 }, //0-20
		{45, 27, 42},//0-22
		
		{14, 15, 8}, //2-00
		{32, 33, 38},//2-02
		
		{53, 17, 2}, //2-20
		{47, 35, 44} //2-22
	};
	static char[][] cornersFaces = new char[][]{
		//X=Y,W; Y=G,B, Z =O,R
		//X    Y    Z
		{'Y', 'G', 'R'}, //0-00
		{'Y', 'G', 'O'}, //0-02
		{'W', 'G', 'R'}, //0-20
		{'W', 'G', 'O'}, //0-22
		
		{'Y', 'B', 'R'}, //2-00
		{'Y', 'B', 'O'}, //2-02
		{'W', 'B', 'R'}, //2-20
		{'W', 'B', 'O'} //
	};
	
	public static int [][]  edges = new int[][]{
		{21, 20}, //A-01
		
		{3, 10},  //A-10
		{39, 28}, //A-12
		
		{48, 18}, //A-21
		
		{13, 7},  //B-00
		{31, 37}, //B-02
		
		{52, 1},  //B-20
		{46, 43}, //B-22
		
		{23, 24}, //C-01
		
		{5, 16},  //C-10
		{34, 41}, //C-12
		
		{50, 26}, //C-21
	};
	public static char[][] edgesFace = new char[][]{
		//X, Y, Z
		{'Y','G','0'},	//A-01
		{'0','G','R'}, //A-10
		{'0','G','O'}, //A-12
		{'W','G','0'}, //A-21
		
		{'Y','0','R'}, //B-00
		{'Y','0','O'}, //B-02
		{'W','0','R'}, //B-20
		{'W','0','O'}, //B-22
		
		{'Y','B','0'}, //C-01
		{'0','B','R'}, //C-10
		{'0','B','O'}, //C-12
		{'W','B','0'}, //C-21
	};
	public static int[] centers = new int[] {22, 49, 4,25, 40, 19};
	public static char[] centersColors = new char[] {'Y', 'W', 'R','B', 'O', 'G'};
	public static char[][]cubeCornerFaces =new char[8][3];
	public static char[][]cubeEdgeFaces = new char[12][6];
	public static HashMap<Integer, int[]> ce= new HashMap<Integer, int[]>();
	
	public static HashMap<Integer,char[]> cubeCornersMap = new HashMap <Integer, char[] > ();
	public static HashMap<Integer, char[]> cubeEdgesMap = new HashMap <Integer, char[] > ();
	
	public static  int[] cubeCorners = new int[8];
	public static  int[] cubeEdges = new int[12];
	static char[] cubieTest = new char[6];
	//indexes of cubes in theses faces, first char = color, second = corner or edge
	//order dependent upon view of face
	int[] faceYC = {0, 4, 5, 1};
	int[] faceYE = {0, 4, 8, 5};
	
	int[] faceWC = {2, 6, 7, 3};
	int[] faceWE = {3, 6, 11, 7};
	
	int[] faceRC= {0, 4, 6, 2};
	int[] faceRE= {1, 4, 9, 6};
	
	int[] faceBC ={5, 4, 6, 7};
	int[] faceBE ={8, 9, 11, 10};
	
	int[] faceOC ={1, 5, 7, 3};
	int[] faceOE ={2,5, 10, 7};
	
	int[] faceGC={0, 2, 3, 1};
	int[] faceGE={0,1, 3, 2};
	
	public String firstState;
	public int cornerState;
	public int edgeState1;
	public int edgeState2;
	public Cube(String input){
		firstState =input;
		
		makeCube(input);
	}
	private static void generateEdgeHashMap(){
		ce.put(0, new int[]{0, 0, 0});
		ce.put(1, new int[]{0, 1, 0});
		ce.put(2, new int[]{0, 1, 2});
		ce.put(3, new int[]{0, 2, 1});
		ce.put(4, new int[]{1, 0, 0});
		ce.put(5, new int[]{1, 0, 2});
		ce.put(6, new int[]{1, 2, 0});
		ce.put(7, new int[]{1, 2, 2});
		ce.put(8, new int[]{2, 0, 1});
		ce.put(9, new int[]{2, 1, 0});
		ce.put(10, new int[]{2, 1, 2});
		ce.put(11, new int[]{2, 2, 1});
	}
	
	
	public void makeCube(String cubeString){
		generateEdgeHashMap();
		
		for (int i =0; i< corners.length; i++){
			//check corners for sticker swap
			cubeCornerFaces[i][0] = cubeString.charAt(corners[i][0]);
			cubeCornerFaces[i][1] = cubeString.charAt(corners[i][1]);
			cubeCornerFaces[i][2] = cubeString.charAt(corners[i][2]);
			cubeCornersMap.put(i, cubeCornerFaces[i]);
			
			for(int j=0; j< cornersFaces.length; j++){
				if (checkFaces(cubeCornerFaces[i], cornersFaces[j])){
					cubeCorners[i] = j;		
				}
					
			}
		}
		
		//parse edges
		for(int i=0; i<edges.length;i++){
			int curColor =0;
			for (int j=0; j<3; j++){
				if (edgesFace[i][j]!='0'){
					cubeEdgeFaces[i][j] = cubeString.charAt(edges[i][curColor]);
					curColor++;
				}
				else 
					cubeEdgeFaces[i][j] = '0';
			}
			cubeEdgesMap.put(i, cubeEdgeFaces[i]);
		}
		//this.rotate('Y', 1);
		//for (int i=0;i<8;i++)
		//	System.out.println(String.valueOf(i)+" " +new String(cubeCornersMap.get(i)));
		System.out.println(encode(mappedCorners(), 8));
		
	}
	private static boolean checkFaces(char[] cubie, char[] defaultCubieFaces){
		for(int i =0; i< cubie.length; i++){
			if ((new String (defaultCubieFaces)).indexOf(cubie[i])==-1){
				return false;
			}
		}
		return true;
	}
	public void rotate(char face, int turns){
		//turns shouldnt be greater than 3
		turns = turns%4;
		for(int i=0; i<turns;i++)
			rotate(face);
	}
	public void rotate(char face){
		HashMap<Integer,char[]> cubeCornersMapCopy = new HashMap <Integer, char[] > (cubeCornersMap);
		HashMap<Integer, char[]> cubeEdgesMapCopy = new HashMap <Integer, char[] > (cubeEdgesMap);
		switch (face){
			case 'Y':{
				
				for (int i=0; i<4; i++){
					
					int currPos =faceYC[i];
					int newPos = (i==3)? faceYC[0] :faceYC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceYE[i];
					newPos = (i==3)? faceYE[0] :faceYE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
			
				break;
			}
			case 'W':{
				for (int i=0; i<4; i++){
					
					int currPos =faceWC[i];
					int newPos = (i==3)? faceWC[0] :faceWC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceWE[i];
					newPos = (i==3)? faceWE[0] :faceWE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
				break;
			}
			case 'R':{
				for (int i=0; i<4; i++){
					
					int currPos =faceRC[i];
					int newPos = (i==3)? faceRC[0] :faceRC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceRE[i];
					newPos = (i==3)? faceRE[0] :faceRE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
				break;
			}
			case 'B':{
				for (int i=0; i<4; i++){
					
					int currPos =faceBC[i];
					int newPos = (i==3)? faceBC[0] :faceBC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceBE[i];
					newPos = (i==3)? faceBE[0] :faceBE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
				break;
			}
			case 'O':{
				for (int i=0; i<4; i++){
					
					int currPos =faceOC[i];
					int newPos = (i==3)? faceOC[0] :faceOC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceOE[i];
					newPos = (i==3)? faceOE[0] :faceOE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
				break;
			}
			case 'G':{
				for (int i=0; i<4; i++){
					
					int currPos =faceGC[i];
					int newPos = (i==3)? faceGC[0] :faceGC[i+1];
					char[] tempCube = cubeCornersMap.get(currPos);
					cubeCornersMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
					currPos =faceGE[i];
					newPos = (i==3)? faceGE[0] :faceGE[i+1];
					tempCube = cubeEdgesMap.get(currPos);
					cubeEdgesMapCopy.put(newPos, new char[] {tempCube[0],tempCube[2],tempCube[1]});
					
				}
				break;
			}
			
		}
		cubeCornersMap = new HashMap <Integer, char[] > (cubeCornersMapCopy);
		cubeEdgesMap = new HashMap <Integer, char[] > (cubeEdgesMapCopy);
		
	}
	/*
	 * creates a map of where the cubie current is to its goal position
	 * */
	private static HashMap<Integer, Integer> mappedCorners(){
		HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();
		for (int i=0; i<8; i++){
			char[] cubeOutofPos = cubeCornersMap.get(i);
			Arrays.sort(cubeOutofPos);
			//System.out.print(new String (cubeOutofPos));
			for(int j=0; j<8; j++){
				char[] cubeGoalPos = cornersFaces[j];
				Arrays.sort(cubeGoalPos);
				//System.out.print(new String(cubeGoalPos));
				if (Arrays.equals(cubeOutofPos, cubeGoalPos)){
					result.put(i, j);
					//System.out.println(i+ " " + j);
					break;
				}
			}
		}
		return result;
	}
	
	private static int encode (HashMap<Integer, Integer> mappedSides, int encodedLength){
		//need to fix, minus i?
		int result =0;
		for (int i =0; i<encodedLength; i++){
			int diff =0;
			int currPos=i;
			int goalPos =mappedSides.get(currPos);
			// Find the shift amount for this current position
			
			//result += (diff) * factorial(encodedLength-i);
			
		}
	
		return result;
	}
	    public static int factorial(int n) {
	        int fact = 1; // this  will be the result
	        for (int i = 1; i <= n; i++) {
	            fact *= i;
	        }
	        return fact;
	    }
	
}